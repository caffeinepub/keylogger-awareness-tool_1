{
  "kind": "implementation_plan",
  "version": "1.0",
  "title": "Implement comprehensive security improvements from code review",
  "requirements": [
    {
      "id": "REQ-1",
      "summary": "Strengthen input sanitization with regex-based validation to block XSS patterns before HTML escaping",
      "acceptanceCriteria": [
        "Block common XSS patterns including <script>, javascript:, data:text/html, and inline event handlers",
        "Validation occurs before HTML entity escaping",
        "All existing sanitization tests continue to pass"
      ],
      "file_operations": [
        {
          "path": "frontend/src/lib/inputSanitizer.ts",
          "operation": "modify",
          "description": "Add comprehensive regex-based validation to detect and block XSS patterns including script tags, javascript: and data: URIs, inline event handlers (onclick, onerror, onload, etc.), and other injection vectors. Implement validation before the existing HTML entity escaping to provide defense-in-depth. Keep existing sanitizeInput, removeHtmlTags, and validateInput functions operational."
        }
      ]
    },
    {
      "id": "REQ-2",
      "summary": "Add Content Security Policy meta tag to restrict script sources and prevent unsafe inline scripts",
      "acceptanceCriteria": [
        "CSP meta tag added to HTML head with script-src, object-src, frame-src, and base-uri directives",
        "Application continues to function with stricter CSP rules",
        "No console CSP violation errors in normal operation"
      ],
      "file_operations": [
        {
          "path": "frontend/index.html",
          "operation": "modify",
          "description": "Add Content-Security-Policy meta tag in the <head> section with directives: script-src 'self' 'unsafe-inline' (required for Vite dev mode and React inline scripts); object-src 'none'; frame-src 'none'; base-uri 'self'. Configure policy to allow the application's existing inline scripts while blocking external and injected scripts. Ensure compatibility with Vite development server and production builds."
        }
      ]
    },
    {
      "id": "REQ-3",
      "summary": "Enhance localStorage encryption with key rotation, HMAC integrity verification, and graceful failure handling",
      "acceptanceCriteria": [
        "Encryption key rotates on each new browser session",
        "HMAC signature validates data integrity before decryption",
        "Corrupted or tampered data fails validation and triggers state reset",
        "Existing encrypted data can be migrated or cleared safely"
      ],
      "file_operations": [
        {
          "path": "frontend/src/lib/storageEncryption.ts",
          "operation": "modify",
          "description": "Implement key rotation by generating a new AES-GCM key on session start (check sessionStorage for existing key, generate if missing). Add HMAC-SHA256 signature generation and verification functions to ensure data integrity. Modify encryptData to compute and prepend HMAC signature. Modify decryptData to verify HMAC before attempting decryption, returning null on signature mismatch or decryption failure. Add version field to encrypted payloads to support future migration."
        },
        {
          "path": "frontend/src/hooks/useSimulationState.ts",
          "operation": "modify",
          "description": "Update state persistence logic to handle decryption failures gracefully. When loading state from localStorage via storageEncryption.decryptData returns null (indicating corruption or tampering), log a warning and initialize with default state instead of throwing. Add error boundary handling for encryption/decryption operations."
        }
      ]
    },
    {
      "id": "REQ-4",
      "summary": "Add rate limiting to keystroke capture with configurable threshold and queue mechanism",
      "acceptanceCriteria": [
        "Keystroke capture rate limited to configurable threshold (e.g., 50 keystrokes/second)",
        "Excess keystrokes are queued or discarded with user notification",
        "Rate limiting does not impact normal typing speeds",
        "Rate limit resets appropriately when simulation is reset"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useSimulationState.ts",
          "operation": "modify",
          "description": "Add rate limiting to the captureKeystroke action using a sliding window algorithm. Store timestamps of recent keystrokes in the store. Configure MAX_KEYSTROKES_PER_SECOND (default 50). Check if adding a new keystroke would exceed the rate limit by counting keystrokes in the last 1-second window. If limit exceeded, either queue the keystroke for delayed processing or discard it and set a rateLimitExceeded flag. Reset rate limiting state in the resetSimulation action."
        },
        {
          "path": "frontend/src/components/SimulatedKeyloggerModule.tsx",
          "operation": "modify",
          "description": "Display a warning message when rate limiting is active (check rateLimitExceeded flag from simulation state). Show an InContextWarning component indicating that typing is being rate-limited for security demonstration purposes. Clear the warning when rate limit resets."
        }
      ]
    },
    {
      "id": "REQ-5",
      "summary": "Implement comprehensive state validation to enforce business rules and prevent malformed state",
      "acceptanceCriteria": [
        "All numeric state values validated within expected ranges",
        "String lengths enforced with maximum limits",
        "Invalid state updates rejected with error logging",
        "State remains consistent even with attempted manipulation"
      ],
      "file_operations": [
        {
          "path": "frontend/src/hooks/useSimulationState.ts",
          "operation": "modify",
          "description": "Add validateState helper function that enforces: riskLevel between 0-100, all counters (keystrokesCount, scansPerformed, blocksExecuted) are non-negative integers, capturedText length <= 10000 characters, typingSpeed >= 0. Wrap all state-modifying actions (captureKeystroke, updateRiskLevel, incrementScanCount, etc.) with validation. Log validation errors to console.error and reject invalid updates by returning early. Add unit tests for validation edge cases."
        }
      ]
    },
    {
      "id": "REQ-6",
      "summary": "Add ARIA live regions to announce dynamic state changes to screen readers",
      "acceptanceCriteria": [
        "aria-live regions added with appropriate politeness levels (polite/assertive)",
        "Dynamic content changes announced to screen readers",
        "Announcements are meaningful and not overly verbose",
        "No duplicate or conflicting ARIA announcements"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/SimulatedAntivirusScanner.tsx",
          "operation": "modify",
          "description": "Add an aria-live=\"polite\" region that announces scan status changes (\"Scanning for threats\", \"Threat detected\", \"Threat quarantined\", \"Threat removed\"). Use visually-hidden text that updates when scanning state changes. Ensure announcements are concise and actionable."
        },
        {
          "path": "frontend/src/components/AttackerDashboardPanel.tsx",
          "operation": "modify",
          "description": "Add an aria-live=\"polite\" region that announces when new keystrokes are captured (e.g., \"Keystroke captured\" every 10 keystrokes to avoid announcement spam). Include announcement when transmission animation completes. Keep announcements brief to avoid overwhelming screen reader users."
        },
        {
          "path": "frontend/src/components/AIRiskDetectorPanel.tsx",
          "operation": "modify",
          "description": "Add an aria-live=\"assertive\" region (due to security-critical nature) that announces significant risk level changes (e.g., when crossing Low/Medium/High thresholds at 30% and 70%). Format announcements as \"Risk level: Medium\" or \"Threat level increased to High\". Avoid announcing every minor risk percentage change."
        }
      ]
    },
    {
      "id": "REQ-7",
      "summary": "Enhance keyboard navigation in TestScenariosPanel with arrow keys, Enter to activate, and Escape to close",
      "acceptanceCriteria": [
        "Arrow keys navigate between scenario cards with visible focus indicator",
        "Enter key activates selected scenario",
        "Escape key closes expanded content and returns focus appropriately",
        "Tab order remains logical and predictable"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/TestScenariosPanel.tsx",
          "operation": "modify",
          "description": "Implement keyboard navigation using onKeyDown handlers. Add arrow key support (ArrowLeft/ArrowRight or ArrowUp/ArrowDown) to move focus between scenario cards using focus management refs. Make scenario cards focusable with tabIndex={0}. Handle Enter key to trigger scenario activation. Add Escape key handler to collapse expanded learning content sections and restore focus to the parent card. Ensure focus indicators are clearly visible using focus-visible styles. Maintain logical tab order."
        }
      ]
    },
    {
      "id": "REQ-8",
      "summary": "Add security headers configuration documentation for Internet Computer canister deployment",
      "acceptanceCriteria": [
        "Documentation file created with header recommendations",
        "Each header explained with purpose and recommended value",
        "Instructions provided for IC canister configuration",
        "Links to IC documentation included"
      ],
      "file_operations": [
        {
          "path": "docs/SECURITY.md",
          "operation": "create",
          "description": "Create comprehensive security documentation explaining HTTP security headers recommended for IC canister configuration. Document X-Frame-Options: DENY (prevent clickjacking), X-Content-Type-Options: nosniff (prevent MIME sniffing), Referrer-Policy: strict-origin-when-cross-origin (privacy), Permissions-Policy (disable unnecessary browser features). Include step-by-step instructions for configuring headers in dfx.json or using IC SDK HTTP response headers API. Provide links to Internet Computer documentation on asset certification and HTTP headers. Include CSP recommendations that complement the meta tag."
        }
      ]
    },
    {
      "id": "REQ-9",
      "summary": "Implement proper cleanup of Three.js resources to prevent WebGL context leaks",
      "acceptanceCriteria": [
        "Geometry and material resources disposed in cleanup function",
        "WebGL context properly released on component unmount",
        "No memory leaks detected after repeated mount/unmount cycles",
        "Visual appearance remains unchanged"
      ],
      "file_operations": [
        {
          "path": "frontend/src/components/ThreeSceneAccent.tsx",
          "operation": "modify",
          "description": "Add comprehensive cleanup in useEffect return function that disposes Three.js resources. Call geometry.dispose() on the torus geometry, material.dispose() on the wireframe material, and renderer.dispose() to release WebGL context. Store references to geometry, material, and renderer in refs if needed for cleanup. Ensure cleanup runs on component unmount and before re-creating scene on dependency changes. Test that the visual appearance (rotating cyan wireframe torus) remains unchanged."
        }
      ]
    },
    {
      "id": "REQ-10",
      "summary": "Optimize React Query configuration with staleTime, cacheTime, retry settings, and request deduplication",
      "acceptanceCriteria": [
        "QueryClient configured with appropriate staleTime (e.g., 5 minutes)",
        "Cache retention time set to prevent memory bloat",
        "Retry logic configured for failed requests",
        "Duplicate simultaneous requests deduplicated automatically"
      ],
      "file_operations": [
        {
          "path": "frontend/src/main.tsx",
          "operation": "modify",
          "description": "Configure QueryClient with optimized defaults: staleTime of 5 minutes (300000ms) to reduce redundant fetches, cacheTime of 10 minutes (600000ms) to balance memory usage and performance, retry logic with 3 attempts and exponential backoff for failed requests, and enable automatic request deduplication (enabled by default but verify). Add refetchOnWindowFocus: false for this educational demo app since data doesn't change server-side. Configure appropriate query and mutation default options."
        }
      ]
    }
  ]
}